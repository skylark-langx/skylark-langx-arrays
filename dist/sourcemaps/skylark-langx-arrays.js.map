{"version":3,"sources":["skylark-langx-arrays.js"],"names":["define","skylark","types","objects","funcs","filter","Array","prototype","find","isArrayLike","baseFindIndex","array","predicate","fromIndex","fromRight","length","index","baseIsNaN","value","contains","item","inArray","difference","restArguments","rest","flatten","filter2","func","call","result","i","j","push","indexOf","makeArray","obj","offset","startWith","concat","slice","otherArrays","attach","baseIndexOf","compact","first","items","n","grep","callback","out","each","toArray","last","arr","merge","second","l","undefined","forEach","fn","map","elements","key","values","reduce","initialValue","uniq","idx","arrays","main"],"mappings":"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","file":"../skylark-langx-arrays.js","sourcesContent":["define('skylark-langx-arrays/arrays',[\r\n  \"skylark-langx-ns\",\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-funcs\"\r\n],function(skylark,types,objects,funcs){\r\n    var filter = Array.prototype.filter,\r\n        find = Array.prototype.find,\r\n        isArrayLike = types.isArrayLike;\r\n\r\n    /**\r\n     * The base implementation of `_.findIndex` and `_.findLastIndex` without\r\n     * support for iteratee shorthands.\r\n     *\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @param {number} fromIndex The index to search from.\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     */\r\n    function baseFindIndex(array, predicate, fromIndex, fromRight) {\r\n      var length = array.length,\r\n          index = fromIndex + (fromRight ? 1 : -1);\r\n\r\n      while ((fromRight ? index-- : ++index < length)) {\r\n        if (predicate(array[index], index, array)) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\r\n     *\r\n     * @param {Array} array The array to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} fromIndex The index to search from.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     */\r\n    function baseIndexOf(array, value, fromIndex) {\r\n      if (value !== value) {\r\n        return baseFindIndex(array, baseIsNaN, fromIndex);\r\n      }\r\n      var index = fromIndex - 1,\r\n          length = array.length;\r\n\r\n      while (++index < length) {\r\n        if (array[index] === value) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `isNaN` without support for number objects.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\r\n     */\r\n    function baseIsNaN(value) {\r\n      return value !== value;\r\n    }\r\n\r\n\r\n    function compact(array) {\r\n        return filter.call(array, function(item) {\r\n            return item != null;\r\n        });\r\n    }\r\n\r\n    function contains(array,item) {\r\n      return inArray(item,array);\r\n    }\r\n\r\n\r\n    // Take the difference between one array and a number of other arrays.\r\n    // Only the elements present in just the first array will remain.\r\n    var difference  = funcs.restArguments(function(array, rest) {\r\n      rest = flatten(rest, true, true);\r\n      return filter2(array, function(value){\r\n        return !contains(rest, value);\r\n      });\r\n    });\r\n\r\n    function filter2(array,func) {\r\n      return filter.call(array,func);\r\n    }\r\n\r\n    function flatten(array) {\r\n        if (isArrayLike(array)) {\r\n            var result = [];\r\n            for (var i = 0; i < array.length; i++) {\r\n                var item = array[i];\r\n                if (isArrayLike(item)) {\r\n                    for (var j = 0; j < item.length; j++) {\r\n                        result.push(item[j]);\r\n                    }\r\n                } else {\r\n                    result.push(item);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            return array;\r\n        }\r\n        //return array.length > 0 ? concat.apply([], array) : array;\r\n    }\r\n\r\n    function grep(array, callback) {\r\n        var out = [];\r\n\r\n        objects.each(array, function(i, item) {\r\n            if (callback(item, i)) {\r\n                out.push(item);\r\n            }\r\n        });\r\n\r\n        return out;\r\n    }\r\n\r\n    function inArray(item, array) {\r\n        if (!array) {\r\n            return -1;\r\n        }\r\n        var i;\r\n\r\n        if (array.indexOf) {\r\n            return array.indexOf(item);\r\n        }\r\n\r\n        i = array.length;\r\n        while (i--) {\r\n            if (array[i] === item) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    function indexOf(array,item) {\r\n      return array.indexOf(item);\r\n    }\r\n\r\n    function makeArray(obj, offset, startWith) {\r\n       if (isArrayLike(obj) ) {\r\n        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));\r\n      }\r\n\r\n      // array of single index\r\n      return [ obj ];             \r\n    }\r\n\r\n\r\n    function forEach (arr, fn) {\r\n      if (arr.forEach) return arr.forEach(fn)\r\n      for (var i = 0; i < arr.length; i++) fn(arr[i], i);\r\n    }\r\n\r\n\r\n    function first(items,n) {\r\n      if (n) {\r\n          return items.slice(0,n);\r\n      } else {\r\n          return items[0];\r\n      }\r\n    }\r\n\r\n    // Get the last element of an array. \r\n    function last(arr) {\r\n        return arr[arr.length - 1];     \r\n    }\r\n\r\n    function map(elements, callback) {\r\n        var value, values = [],\r\n            i, key\r\n        if (isArrayLike(elements))\r\n            for (i = 0; i < elements.length; i++) {\r\n                value = callback.call(elements[i], elements[i], i);\r\n                if (value != null) values.push(value)\r\n            }\r\n        else\r\n            for (key in elements) {\r\n                value = callback.call(elements[key], elements[key], key);\r\n                if (value != null) values.push(value)\r\n            }\r\n        return flatten(values)\r\n    }\r\n\r\n\r\n    function merge( first, second ) {\r\n      var l = second.length,\r\n          i = first.length,\r\n          j = 0;\r\n\r\n      if ( typeof l === \"number\" ) {\r\n        for ( ; j < l; j++ ) {\r\n          first[ i++ ] = second[ j ];\r\n        }\r\n      } else {\r\n        while ( second[j] !== undefined ) {\r\n          first[ i++ ] = second[ j++ ];\r\n        }\r\n      }\r\n\r\n      first.length = i;\r\n\r\n      return first;\r\n    }\r\n\r\n    function reduce(array,callback,initialValue) {\r\n        return Array.prototype.reduce.call(array,callback,initialValue);\r\n    }\r\n\r\n    function uniq(array) {\r\n        return filter.call(array, function(item, idx) {\r\n            return array.indexOf(item) == idx;\r\n        })\r\n    }\r\n\r\n    function find2(array,func) {\r\n      return find.call(array,func);\r\n    }\r\n\r\n\r\n    // Return a version of the array that does not contain the specified value(s).\r\n    var without = funcs.restArguments(function(array, otherArrays) {\r\n      return difference(array, otherArrays);\r\n    });\r\n\r\n    return skylark.attach(\"langx.arrays\",{\r\n        baseFindIndex: baseFindIndex,\r\n\r\n        baseIndexOf : baseIndexOf,\r\n        \r\n        compact: compact,\r\n\r\n        contains,\r\n\r\n        difference,\r\n\r\n        filter : filter2,\r\n\r\n        find : find2,\r\n\r\n        first,\r\n\r\n        flatten: flatten,\r\n\r\n        grep: grep,\r\n\r\n        inArray: inArray,\r\n\r\n        indexOf : indexOf,\r\n\r\n        makeArray: makeArray, // \r\n\r\n        toArray : makeArray,\r\n\r\n        last : last,\r\n\r\n        merge : merge,\r\n\r\n        forEach : forEach,\r\n\r\n        map : map,\r\n        \r\n        reduce : reduce,\r\n\r\n        uniq : uniq\r\n\r\n    });\r\n});\ndefine('skylark-langx-arrays/main',[\r\n\t\"./arrays\"\r\n],function(arrays){\r\n\treturn arrays;\r\n});\ndefine('skylark-langx-arrays', ['skylark-langx-arrays/main'], function (main) { return main; });\n\n"]}